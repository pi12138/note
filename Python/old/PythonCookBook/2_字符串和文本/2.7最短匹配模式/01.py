"""
问题
    你正在试着用正则表达式匹配某个文本模式，但是它找到的是模式的最长可能匹
配。而你想修改它变成查找最短的可能匹配。
"""

"""
解决方案
    这个问题一般出现在需要匹配一对分隔符之间的文本的时候 (比如引号包含的字符
串)。为了说明清楚，考虑如下的例子：
"""
import re

text1 = 'Computer says "no."'
text2 = 'Computer says "no." Phone says "yes."'

pattern = re.compile(r'\"(.*)\"')

result1 = pattern.findall(text1)
result2 = pattern.findall(text2)

print(result1)  # ['no.']
print(result2)  # ['no." Phone says "yes.']

# 正则表达式匹配时，默认是贪婪匹配，匹配操作可能会查找最长的符合匹配要求的数据

"""
在这个例子中，模式 r'\"(.*)\"' 的意图是匹配被双引号包含的文本。但是在正
则表达式中 * 操作符是贪婪的，因此匹配操作会查找最长的可能匹配。于是在第二个
例子中搜索 text2 的时候返回结果并不是我们想要的。
"""

"""
为了修正这个问题，可以在模式中的 * 操作符后面加上? 修饰符，就像这样：
"""

pattern2 = re.compile(r'\"(.*?)\"') # 加上？后匹配模式就从贪婪模式变为非贪婪模式

result1 = pattern2.findall(text1)
result2 = pattern2.findall(text2)

print(result1)
print(result2)

"""
这样就使得匹配变成非贪婪模式，从而得到最短的匹配，也就是我们想要的结果。
讨论
这一节展示了在写包含点 (.) 字符的正则表达式的时候遇到的一些常见问题。在一
个模式字符串中，点 (.) 匹配除了换行外的任何字符。然而，如果你将点 (.) 号放在开始
与结束符 (比如引号) 之间的时候，那么匹配操作会查找符合模式的最长可能匹配。这
样通常会导致很多中间的被开始与结束符包含的文本被忽略掉，并最终被包含在匹配
结果字符串中返回。通过在 * 或者 + 这样的操作符后面添加一个 ? 可以强制匹配算法
改成寻找最短的可能匹配。
"""