'''
如果你想在一个集合中查找最小或最大的 N 个元素，并且 N 小于集合元素数量，
那么这些函数提供了很好的性能。因为在底层实现里面，首先会先将集合数据进行堆排
序后放入一个列表中

堆数据结构最重要的特征是 heap[0] 永远是最小的元素。并且剩余的元素可以很
容易的通过调用 heapq.heappop() 方法得到，该方法会先将第一个元素弹出来，然后
用下一个最小的元素来取代被弹出元素（这种操作时间复杂度仅仅是 O(log N)，N 是
堆大小）。比如，如果想要查找最小的 3 个元素，你可以这样做：

当要查找的元素个数相对比较小的时候，函数 nlargest() 和 nsmallest() 是很
合适的。如果你仅仅想查找唯一的最小或最大（N=1）的元素的话，那么使用 min() 和
max() 函数会更快些。类似的，如果 N 的大小和集合大小接近的时候，通常先排序这个
集合然后再使用切片操作会更快点（sorted(items)[:N] 或者是 sorted(items)[-N:]
）。需要在正确场合使用函数 nlargest() 和 nsmallest() 才能发挥它们的优势（如果
N 快接近集合大小了，那么使用排序操作会更好些）。
尽管你没有必要一定使用这里的方法，但是堆数据结构的实现是一个很有趣并且
值得你深入学习的东西。基本上只要是数据结构和算法书籍里面都会有提及到。heapq
模块的官方文档里面也详细的介绍了堆数据结构底层的实现细节。
'''

import heapq

nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
print("nums:",nums)

heap = list(nums)
print("heap:",heap)

# 堆排序
heapq.heapify(heap)
print("heap:",heap)

for i in range(1,len(heap)+1):
    num = heapq.heappop(heap)
    print("{0} --- {1}".format(i,num))
    print(heap)